---
title: "Glacierpoint - glom() Demo"
subtitle: 'v0.1.1 - last updated 2019/02/14'
author: "Andrew Brown; andrew.g.brown@ca.usda.gov"
version: "0.1.1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this demo, we use the _aqp_ functions `glom()` and `profileApply()` to analyze a depth-subset of horizons from each profile in a _SoilProfileCollection_.

`glom()` returns the horizon(s) that intersect the specified depth [_z1_] or depth interval [_z1_, _z2_].

### Checking for cambic horizon criteria

First, the script queries components by component name, then gets records populated in the _Component Diagnostic Features_ (`codiagfeatures`) table. 

A custom function `has_sandy_cambic()` is defined to use `glom()` on each profile (`p`) in `my.spc`.

`glom()` is used along with the top and bottom depth of the cambic (which we added to `site` table) to get _all horizons that are part of the specified (cambic) depth range_.

A pair of regular expression patterns are used to check the `glom()`-ed horizons for stratified and/or sandy textures. If either stratified or sandy textures are found, the function returns `TRUE`. Otherwise, the function returns `FALSE`.

***

This demonstration script loads some components from Yosemite National Park (_CA790_). In this simple example, we look at some components correlated to _Glacierpoint_.

The _Glacierpoint_ series (_Sandy-skeletal, isotic Xeric Dystrocryepts_) is defined as having __either__ an Umbric epipedon __OR__ a cambic horizon. It appears that cambic horizons were populated even for the components whose RV textures do not meet cambic criteria.

```{r message=F, warning=F}
# load soilDB
library(soilDB)

# get components from Yosemite National Park for a sandy-skeletal, cryic, inceptisol
my.spc <- fetchSDA_component(WHERE="compname = 'Glacierpoint'")
```

`fetchSDA_component()` does not return diagnostic feature info by default. We need to query SDA specifically to obtain that info.

```{r message=F, warning=F}
# custom function using SDA_query() to get the diagnostic table
get_SDA_diagnostics <- function(my.spc) {
  target_cokeys <- site(my.spc)[,idname(my.spc)]
  q <- paste0('SELECT * FROM codiagfeatures WHERE cokey IN ', format_SQL_in_statement(target_cokeys), ";")
  return(SDA_query(q))
}

# query diagnostic info from SDA and 
# set @diagnostics slot of my.spc to contain them
diagnostic_hz(my.spc) <- get_SDA_diagnostics(my.spc)
```

SPC-creating functions may require you to independently query the diagnostic features into a _data.frame_ and set them for your SPC, as we did above. Alternately, you can create your SPC other ways. For instance, the `fetchNASIS_XXX()` results include the diagnostic feature table _by default_.

Now, access the SPC `@diagnostics` slot (which we just filled in), figure out which components have cambics, and then make a subset SPC `my.spc.sub` with _just those components_.

```{r message=F, warning=F}
# copy contents of diagnostics slot
diagz <- diagnostic_hz(my.spc)

# create a subset SPC with just profiles that have a cambic in their diagnostics
my.spc.sub <- my.spc[profile_id(my.spc) %in% 
                       diagz[grepl(diagz$featkind, pattern="[Cc]ambic"), idname(my.spc)],]
```

A total of `r length(my.spc.sub)` components out of `r length(my.spc)` have cambic horizons. 

Let's inspect those `r length(my.spc.sub)` components visually. 

Use `plotSPC()` to show sand fraction percentage by horizon -- with cambic top and bottom depths portrayed with bracket annotation (using `aqp::addDiagnosticBracket()`).

```{r message=F, warning=F}
par(mar=c(0,0,3,0))
plot(my.spc.sub, color='sandtotal_r', width=0.15)
addDiagnosticBracket(my.spc.sub, kind='Cambic horizon', 
                     top='featdept_r', bottom='featdepb_r',
                     col='red', offset=-0.25)
```

***

Now that we have the data and have done some preliminary inspection, let's define a regular expression pattern and a function to check our cambic criteria. 

Define a custom function `has_sandy_cambic()` to test horizons _within the cambic depth range_ for each profile. The default arguement `sandy.texture.pattern` matches stratified or sandy textures. If any such textures are found, the function returns `TRUE`.

```{r message=F, warning=F}
# p is a single profile SPC 
has_sandy_cambic <- function(p, sandy.texture.pattern = "SR|-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$") {
  d <- diagnostic_hz(p)
  d.cambic.idx <- grep(d$featkind, pattern="[Cc]ambic")
  cambic_top <- d[d.cambic.idx, 'featdept_r']
  cambic_bot <- d[d.cambic.idx, 'featdepb_r']
  
  # if top or bottom depth are NULL there is no cambic
  if(!is.null(cambic_top) | !is.null(cambic_bot)) {
    
    # call glom to get horizons in p between cambic_top and cambic_bot
    cambic_horizons <- glom(p, cambic_top, cambic_bot)
    
    print(paste0("COKEY: ",unique(p$cokey)," has cambic (",
                 cambic_top," - ",cambic_bot," cm) with texture class: ",
                 paste0(cambic_horizons$texture, collapse=", ")))
  
    # use a regular expression to match the sandy textures
    if(any(grepl(cambic_horizons$texture, 
                 pattern = sandy.texture.pattern, 
                 ignore.case = TRUE))) {
      return(TRUE) 
    }  
  }
  
  return(FALSE)
}
```

Apply the function to each profile.

```{r message=F, warning=F}
# apply function has_sandy_cambic() to each profile
my.spc.sub$sandy_cambic <- profileApply(my.spc.sub, has_sandy_cambic)
```

Inspect results. Print out the offending unique profile IDs (`cokey`).

```{r message=F, warning=F}
# do any components have a sandy cambic?
if(any(my.spc.sub$sandy_cambic)) {
  print(paste0("The following components have sandy cambics: ",
        paste0(profile_id(my.spc.sub)[my.spc.sub$sandy_cambic], collapse=",")))
} else {
  print("All components with cambics have appropriate textures.")
}
```

----------------------------
This document is based on `aqp` version `r utils::packageDescription("aqp", field="Version")`, `soilDB` version `r utils::packageDescription("soilDB", field="Version")`, and `sharpshootR` version `r utils::packageDescription("sharpshootR", field="Version")`.
