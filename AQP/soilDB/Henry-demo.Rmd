---
output:
  html_document:
    mathjax: null
    jquery: null
    smart: no
---

```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr, quietly=TRUE)
library(printr, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```

Henry Mount Soil Climate Database Tutorial
==========================================
D.E. Beaudette
<br>
`r format(Sys.time(), "%Y-%m-%d")`


## Introduction
This document demonstrates how to use the [soilDB](http://ncss-tech.github.io/AQP/soilDB/soilDB-Intro.html) package to download data from the Henry Mount soil climate database. Soil climate data are routinely collected by SSO staff via buried sensor/data-logger devices ("hobos") and now above ground weather stations. The Henry Mount Soil Climate database was established to assist with the management and analysis of these data.


## Setup R Environment
With a recent version of R (>= 2.15), it is possible to get all of the packages that this tutorial depends on via:
```{r install-deps, eval=FALSE}
# run these commands in the R console
install.packages('RColorBrewer', dep=TRUE)
install.packages('reshape', dep=TRUE)
install.packages('dismo', dep=TRUE)
install.packages('rgdal', dep=TRUE)
install.packages('soilDB', dep=TRUE)
# get latest version from GitHub
install.packages('devtools', dep=TRUE)
devtools::install_github("ncss-tech/soilDB", dependencies=FALSE, upgrade_dependencies=FALSE)
```


## Getting and Viewing Data
Soil climate data can be queried by:
 
 * project (typically a soil survey area, "CA630")
 * NASIS user site ID (e.g. "2006CA7920001")
 * MLRA soil survey office (e.g. "2-SON")

and optionally filtered by:

 * start date ("YYYY-MM-DD")
 * end date ("YYYY-MM-DD")
 * sensor type ("soiltemp" is the only type currently available)
 
and aggregated to the following granularity:

 * "day" (MAST and mean summer/winter temperatures are automatically computed)
 * "week"
 * "month"
 * "year"


Query daily sensor data associated with the Sequoia / Kings Canyon soil survey.
```{r get-data, fig.width=6, fig.height=7, results='hide'}
library(soilDB)
library(lattice)
library(RColorBrewer)
library(plyr)

# get soil temperature, soil moisture, and air temperature data
x <- fetchHenry(project='CA792')

# check object structure:
str(x, 2)
```

Quick listing of essential site-level data. "Functional years" is the number of years of non-missing data, after grouping data by Julian day. "Complete years" is the number of years that have 365 days of non-missing data. "dslv" is the number of days since the data-logger was last visited.
```{r view-data, fig.width=6, fig.height=7}
# convert into data.frame
d <- as.data.frame(x$sensors)
# keep only information on soil temperature sensors
d <- subset(d, subset=sensor_type == 'soiltemp')
# check top 6 rows and select columns
head(d[, c('user_site_id', 'name', 'sensor_depth', 'MAST', 'Winter', 'Summer', 'STR', 'functional.yrs', 'complete.yrs', 'dslv')])
```


### Plot Data
Note that there are gaps in the data: between site visits and lack of synchronization of site visits with start/end of the year.
```{r plot-time-series, fig.width=10, fig.height=9}
xyplot(sensor_value ~ date_time | name, data=x$soiltemp, main='Daily Soil Temperature (Deg. C)', type=c('l', 'g'), as.table=TRUE, layout=c(2,9), xlab='Date', ylab='Deg C')
xyplot(sensor_value ~ date_time | name, data=x$soilVWC, main='Daily Soil Moisture', type=c('l', 'g'), as.table=TRUE, layout=c(2,6), xlab='Date', ylab='Deg C')
```


Another approach for investigating data gaps, blue: data, grey: no data.
```{r plot-time-series-levelplot, fig.width=9, fig.height=11}
levelplot(factor(!is.na(sensor_value)) ~ doy * factor(year) | name, main='Daily Soil Temperature (Deg. C)',
data=x$soiltemp, layout=c(2,7), col.regions=c('grey', 'RoyalBlue'), cuts=1, 
colorkey=FALSE, as.table=TRUE, scales=list(alternating=3, cex=0.75), 
par.strip.text=list(cex=0.85), strip=strip.custom(bg='yellow'), 
xlab='Julian Day', ylab='Year')

levelplot(factor(!is.na(sensor_value)) ~ doy * factor(year) | name, main='Daily Soil Moisture',
data=x$soilVWC, layout=c(2,4), col.regions=c('grey', 'RoyalBlue'), cuts=1, 
colorkey=FALSE, as.table=TRUE, scales=list(alternating=3, cex=0.75), 
par.strip.text=list(cex=0.85), strip=strip.custom(bg='yellow'), 
xlab='Julian Day', ylab='Year')

# levelplot(factor(!is.na(sensor_value)) ~ doy * factor(year) | name, main='Daily Air Temperature (Deg. C)',
# data=x$airtemp, layout=c(1,1), col.regions=c('grey', 'RoyalBlue'), cuts=1, 
# colorkey=FALSE, as.table=TRUE, scales=list(alternating=3, cex=0.75), 
# par.strip.text=list(cex=0.85), strip=strip.custom(bg='yellow'), 
# xlab='Julian Day', ylab='Year')
```

This style of plotting data can be useful for making comparisons between years. 
```{r plot-time-series-levelplot-2, fig.width=9, fig.height=11.5}
# generate some better colors
cols <- colorRampPalette(rev(brewer.pal(11, 'RdYlBu')), space='Lab', interpolate='spline')

levelplot(sensor_value ~ doy * factor(year) | name, main='Daily Soil Temperature (Deg. C)',
data=x$soiltemp, layout=c(2,7), col.regions=cols,
colorkey=list(space='top'), as.table=TRUE, scales=list(alternating=3, cex=0.75), 
par.strip.text=list(cex=0.85), strip=strip.custom(bg='grey'), 
xlab='Julian Day', ylab='Year')

levelplot(sensor_value ~ doy * factor(year) | name, main='Daily Soil Moisture',
data=x$soilVWC, layout=c(2,4), col.regions=cols,
colorkey=list(space='top'), as.table=TRUE, scales=list(alternating=3, cex=0.75), 
par.strip.text=list(cex=0.85), strip=strip.custom(bg='grey'), 
xlab='Julian Day', ylab='Year')
```


Aggregate over years by sensor / Julian day.
```{r plot-time-series-levelplot-3, fig.width=9, fig.height=6}

# compute MAST by sensor
a <- ddply(x$soiltemp, c('name', 'doy'), .fun=plyr::summarise, soiltemp=mean(sensor_value, na.rm = TRUE))
# re-order sensor names according to MAST
a.mast <- sort(tapply(a$soiltemp, a$name, mean, na.rm=TRUE))
a$name <- factor(a$name, levels=names(a.mast))

levelplot(soiltemp ~ doy * name, main='Daily Soil Temperature (Deg. C)',
data=a, col.regions=cols, xlab='Julian Day', ylab='',
colorkey=list(space='top'), scales=list(alternating=3, cex=0.75, x=list(tick.number=15)))
```



Convert data to percent saturation. (still working on this)
```{r, fig.width=9, fig.height=11.5, eval=FALSE}
fun <- function(i) {
  i$pct.sat <- i$sensor_value / max(i$sensor_value, na.rm = TRUE)
  return(i)
}

z <- ddply(x$soilVWC, c('sid', 'year'), .fun=fun)
z$pct.sat <- factor(z$pct.sat >= 0.5, levels = c('TRUE', 'FALSE'), labels = c('Moist', 'Dry'))

levelplot(pct.sat ~ doy * factor(year) | name, main='Daily Soil Moisture',
data=z, layout=c(2,4), col.regions=c('grey', 'RoyalBlue'), cuts=1,
colorkey=FALSE, as.table=TRUE, scales=list(alternating=3, cex=0.75), 
par.strip.text=list(cex=0.85), strip=strip.custom(bg='grey'), 
xlab='Julian Day', ylab='Year')
```


## Data Summaries

In the presence of missing data, MAST calculations will be biased towards those data that are not missing. For example, a block of missing data in January will result in an estimated MAST that is too high due to the missing data from the middle of winter. It is possible to estimate (mostly) unbiased MAST values in the presence of some missing data by averaging multiple years of data by Julian day.  This approach will generate reasonable summaries in the presence of missing data, as long as data gaps are "covered" by corresponding data from another year. The longer the period of record and shorter the data gaps, the better.

Soil temperature regime assignment for gelic, cryic, and frigid conditions typically require additional information and are marked with an '*'.

When daily data are queried, unbiased summaries and indices of data "completeness" are calculated.
```{r data-summary, fig.width=6, fig.height=7}
as.data.frame(x$sensors)[which(!is.na(x$sensors$MAST)), c('user_site_id', 'sensor_depth', 'name', 'MAST', 'Winter', 'Summer', 'STR', 'functional.yrs', 'complete.yrs', 'gap.index')]
```




### Additional Ideas

1. Save sites as shape file
```{r save-as-shp, eval=FALSE}
library(rgdal)
writeOGR(x$sensors, dsn='foldername', layer='filename', driver='ESRI Shapefile')
```

2. Overlay site locations on a Google map
```{r map-data, eval=FALSE}
library(dismo)
g <- gmap(x$sensors)
plot(g, interpolate=TRUE)
points(Mercator(x$sensors), col='red')
```


----------------------------
This document is based on `aqp` version `r utils::packageDescription("aqp", field="Version")` and `soilDB` version `r utils::packageDescription("soilDB", field="Version")`.

