---
title: "Getting and Comparing KSSL Data"
author: "D.E. Beaudette"
date: "`r Sys.Date()`"
output:
  html_document:
    mathjax: null
    jquery: null
    smart: no
---

```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```

# Introduction
This document demonstrates how to use the [soilDB](http://ncss-tech.github.io/AQP/soilDB/soilDB-Intro.html) package to download [KSSL](http://ncsslabdatamart.sc.egov.usda.gov/) data from SoilWeb. These data are from the [September 2018 snapshot](https://github.com/dylanbeaudette/process-kssl-snapshot), and will be updated as future snapshots are released. Comparisons are made via graphical summaries of key soil properties with depth, using [data structures and functions](hhttp://ncss-tech.github.io/AQP/aqp/aqp-intro.html) from the [aqp](http://ncss-tech.github.io/AQP/) package.

## Installation
With a recent version of R (>= 2.15), it is possible to get all of the packages that this tutorial depends on via:
```{r install-deps, eval=FALSE}
# stable packages from CRAN
install.packages('maps', dep=TRUE)
install.packages('plyr', dep=TRUE)
install.packages('reshape2', dep=TRUE)
install.packages('soilDB', dep=TRUE)

# latest versions from GitHub
remotes::install_github("ncss-tech/aqp", dependencies=FALSE, upgrade_dependencies=FALSE)
remotes::install_github("ncss-tech/soilDB", dependencies=FALSE, upgrade_dependencies=FALSE)
```


# Quick Example: getting lab characterization (KSSL) and basic morphology (NASIS)
KSSL and NASIS data are from the September 2018 snapshot. Details pending.
```{r}
library(aqp)
library(soilDB)
library(plyr)
library(reshape2)

# get lab and morphologic data
# simplify colors to 1 color (moist and dry) per horizon via mixing
# see ?mix_and_clean_colors for details.
s <- fetchKSSL(series='auburn', returnMorphologicData = TRUE, simplifyColors = TRUE)

# extract pedons into SoilProfileCollection
pedons <- s$SPC
```


```{r}
# the result is a list, check it out
str(s, 2)

# check out the "raw" morphologic data:
lapply(s$morph, head)
```


```{r fig.width=10, fig.height=6}
# check
par(mar=c(0,0,0,0))
plot(pedons, color='moist_soil_color', print.id=FALSE, name='hzn_desgn')
```


Simplification of fragment data is still a manual process.
```{r fig.width=10, fig.height=6}
# simplify fragment data
s.frags <- simplfyFragmentData(s$morph$phfrags, id.var='labsampnum')

# merge fragment data into SPC
h <- horizons(pedons)
h <- join(h, s.frags, by='labsampnum', type='left', match='first')
horizons(pedons) <- h


# check
par(mar=c(0,0,3,0))
plot(pedons, color='total_frags_pct', print.id=FALSE, name='hzn_desgn')
addVolumeFraction(pedons, 'total_frags_pct', pch=1, cex.min=0.25, cex.max = 0.5)
```

## Fragment Volume >= 100%
There are cases where errors in the source data (NASIS `Pedon Horizon Fragments` table) suggest coarse fragment volume > 100%. As of `soilDB` 2.0.2 and `aqp` 1.15.4, the `simplfyFragmentData()` function will report such errors and the `addVolumeFraction()` function will fail gracefully by truncating fragment volume at 100%.

Give it a try with an example (thanks to Brian Gardner for finding it).
```{r fig.width=6, fig.height=4, warning=TRUE}
# get lab and morphologic data
s <- fetchKSSL(series='kettenbach', returnMorphologicData = TRUE)

# extract pedons into SoilProfileCollection
pedons <- s$SPC

# simplify fragment data
s.frags <- simplfyFragmentData(s$morph$phfrags, id.var='labsampnum')

# merge fragment data into SPC
h <- horizons(pedons)
h <- join(h, s.frags, by='labsampnum', type='left', match='first')
horizons(pedons) <- h

# flag horizons with >= 100% total fragment volume
pedons$fragment_errors <- factor(pedons$total_frags_pct >= 100)

# label pedons with user pedon ID
# label horizons with total fragment %
par(mar=c(0,0,3,5))
plot(pedons, color='fragment_errors', name='total_frags_pct', label='pedon_id', cex.name=0.85)
addVolumeFraction(pedons, 'total_frags_pct', pch=1, cex.min=0.25, cex.max = 0.5)
```


Check the original fragment data, based on the warnings issued by `simplfyFragmentData()`. Looks like multiple versions of the same data were accidentally entered. Errors like this can be corrected in NASIS, but may require assistance from the regional staff depending on KSSL pedon ownership. `fetchKSSL()` is based on a snapshot of NASIS and LIMS data, therefore corrections may not be available until after the next release cycle.
```{r}
# identify and print affected rows
idx <- which(s$morph$phfrags$labsampnum %in% c('82P02200', '82P02204'))
s$morph$phfrags[idx, ]
```

# Fetch Data Associated with a Set of IDs
Fetching KSSL data for a set of IDs requires some additional "helper" functions. The following example fetches data according to a vector of "pedlabsampnum" IDs, extracts the horizon color data, filters missing data, and combines the results into a single table.

First, paste the following code into your script or console to initialize our helper functions.
```{r}
# get data associated with a single ID
# no records -> NULL returned
getPedons <- function(x) {
  suppressMessages(fetchKSSL(pedlabsampnum=x, returnMorphologicData = TRUE))
}

# extract a morphologic table from each record set
# NULL data are filtered out
# converted to data.frame
extractMorphTable <- function(x, table='phcolor') {
  m <- lapply(x, function(i) i[['morph']][[table]])
  # index pedons with data
  idx <- which(sapply(m, length) > 0) 
  if(length(idx) < 1)
    return(NULL)
  # filter non-NULL and convert to DF
  m <- ldply(m[idx])
  return(m)
}
```

Next, use the `getPedons()` helper function to fetch lab and morphologic data according to a vector of `pedlabsampnum` IDs. Note that the results are a list of lists. Select morphologic data are extracted and combined with the `extractMorphTable()` function.
```{r}
# pedons indexed by "pedlabsampnum" ID
pls <- c("04N0610", "04N0611", "04N0612", "04N0613")
# iterate over IDs and get data
res <- lapply(pls, getPedons)

# check: OK
str(res, 2)

# extract phcolor data from list of records
# result is a data.frame with all non-NULL rows
phcolor <- extractMorphTable(res, table='phcolor')

# check: OK
head(phcolor)
```

Finally, extract the `SoilProfileCollection` objects from `res` and combine into a single object. We can now join our combined color data with the combined pedon data.
```{r fig.width=8, fig.height=5}
# extract pedons from list
pedons <- lapply(res, function(i) i$SPC)
# combine into a single SPC object
pedons <- do.call('rbind', pedons)

# check: looks good
plot(pedons, color='estimated_ph_h2o', name='hzn_desgn')

# simplify combined color data
colors <- simplifyColorData(phcolor, id.var = 'labsampnum', wt='colorpct')

# join combined color data to SPC
h <- horizons(pedons)
h <- join(h, colors, by='labsampnum', type='left', match='first')
horizons(pedons) <- h

# check: looks good
plot(pedons, color='moist_soil_color', name='hzn_desgn')
```


# Example Application
Data can be queried by "taxonname"" (typically a soil series), using a geographic bounding-box in WGS84 referenced coordinates, or by MLRA. Taxonname matching is case-insensitive and based on the most current taxonname in NASIS. See `?fetchKSSL()` or [this GitHub repository](https://github.com/dylanbeaudette/process-kssl-snapshot) for details.

In this example, we are downloading KSSL data for the [musick](https://soilseriessc.egov.usda.gov/OSD_Docs/M/MUSIC.html), [chaix](https://soilseries.sc.egov.usda.gov/OSD_Docs/C/CHAIX.html), and [holland](https://soilseries.sc.egov.usda.gov/OSD_Docs/H/HOLLAND.html) soils; commonly found on granitic rocks of the Sierra Nevada Mountain region of California.
```{r get-data, fig.width=6, fig.height=7}
# load libraries
library(soilDB)
library(plyr)
library(lattice)
library(maps)

# define plotting style
tps <- list(superpose.line=list(col=c('RoyalBlue', 'DarkRed', 'DarkGreen'), lwd=2))

# fetch KSSL data by fuzzy-matching of series name
musick <- fetchKSSL('musick')
holland <- fetchKSSL('holland')
chaix <- fetchKSSL('chaix')

# generate a basemap of northern California, with county boundaries
map('county', 'California', xlim=c(-123.25, -118.75), ylim=c(36.5, 41))
# add long/lat axes
map.axes()
# add locations of musick
points(y ~ x, data=site(musick), pch=21, bg='RoyalBlue')
# add locations of holland
points(y ~ x, data=site(holland), pch=21, bg='DarkRed')
# add locations of chaix
points(y ~ x, data=site(chaix), pch=21, bg='DarkGreen')
# add a simple legend
legend('topright', pch=21, pt.bg=c('RoyalBlue', 'DarkRed', 'DarkGreen'), legend=c('musick', 'holland', 'chaix'), bty='n')
```




## Profile Plots
Generate "thematic" profile sketches by coloring horizons according to clay content.
```{r plot-pedons, fig.width=10, fig.height=6}
par(mar=c(0,1,5,1))
plot(musick, name='hzn_desgn', color='clay')
plot(holland, name='hzn_desgn', color='clay')
plot(chaix, name='hzn_desgn', color='clay')
```


## Combining Data
Since the results from `fetchKSSL()` function always returns data in the same format, it is possible to stack the results of several KSSL queries using `rbind()`.
```{r combine-data, fig.width=10, fig.height=6}
# check "correlated as" names from each object
table(musick$taxonname)
table(holland$taxonname)
table(chaix$taxonname)

# since there are multiple permuations of each, normalize soil series name by replacement
musick$taxonname <- 'musick'
holland$taxonname <- 'holland'
chaix$taxonname <- 'chaix'

# stack datasets into a new SoilProfileCollection
g <- rbind(chaix, musick, holland)

# compute weighted-mean particle diameter
g$wmpd <- with(horizons(g), ((vcs * 1.5) + (cs * 0.75) + (ms * 0.375) + (fs * 0.175) + (vfs *0.075) + (silt * 0.026) + (clay * 0.0015)) / (vcs + cs + ms + fs + vfs + silt + clay))

# tabulate number of pedons by normalized series name
table(g$taxonname)

# plot the grouped object, with profiles arranged by taxonname
par(mar=c(0,1,5,1))
groupedProfilePlot(g, groups = 'taxonname', color='clay', group.name.offset = -10)

# estimate soil depth based on horizon designations
sdc <- getSoilDepthClass(g, name='hzn_desgn', top='hzn_top', bottom='hzn_bot')

# splice-into site data
site(g) <- sdc

# summarize soil depth by taxonname
tapply(g$depth, g$taxonname, summary)
```


## Aggregation
The `slab()` function is used to aggregate selected variables within collections of soil profiles along depth-slices. In this case, we aggregate clay, pH (1:1 H2O, estimated from saturated paste pH when missing), and base saturation at pH 8.2 along 1-cm thick slices and within groups defined by the variable 'taxonname'. See `?slab()` for details on how this function can be used.
```{r aggregate}
g.slab <- slab(g, taxonname ~ clay + estimated_ph_h2o + bs82 + wmpd)

# inspect stacked data structure
str(g.slab)
```


## Refine Labels
It is convenient to know how many pedons there are within each collection--therefore, we append this value to the series name. Using the same approach, we can rename the soil properties with more useful descriptions and units of measure.
```{r rename}
# re-name soils with series name + number of pedons-- order is critical !
new.levels <- c('musick', 'holland', 'chaix')
new.labels <- paste(new.levels, ' [', c(length(musick), length(holland), length(chaix)), ' pedons]', sep='')
g.slab$taxonname <- factor(g.slab$taxonname, levels=new.levels, labels=new.labels)

# new names should match the order in:
levels(g.slab$variable)

# re-name soil property labels-- order is critical !
levels(g.slab$variable) <- c('Clay (%)', 'pH 1:1 H2O', 'Base Saturation at pH 8.2 (%)', 'WMPD (mm)')
```


## Graphically Compare
The slice-wise median and 25th/75th percentiles are reasonable estimations of central tendency and spread. "Contributing fraction" values (% of pedons with data at a given depth) are printed along the right-hand side of each panel. These values provide both an indication of how deep the soils are, and, how much confidence can be placed in the aggregate data at any given depth.
```{r plot, fig.width=10, fig.height=6}
# plot grouped, aggregate data
xyplot(top ~ p.q50 | variable, groups=taxonname, data=g.slab, ylab='Depth',
			 xlab='median bounded by 25th and 75th percentiles',
			 lower=g.slab$p.q25, upper=g.slab$p.q75, ylim=c(155,-5),
			 panel=panel.depth_function, alpha=0.25, sync.colors=TRUE,
			 prepanel=prepanel.depth_function,
			 cf=g.slab$contributing_fraction,
       par.strip.text=list(cex=0.8),
			 strip=strip.custom(bg=grey(0.85)),
			 layout=c(4,1), scales=list(x=list(alternating=1, relation='free'), y=list(alternating=3)),
			 par.settings=tps,
			 auto.key=list(columns=3, lines=TRUE, points=FALSE)
)
```





----------------------------
This document is based on `aqp` version `r utils::packageDescription("aqp", field="Version")` and `soilDB` version `r utils::packageDescription("soilDB", field="Version")`.