---
title: "gNATSGO / gSSURGO Web Coverage Service"
author: "D.E. Beaudette"
date: "`r Sys.Date()`"
output:
  html_document:
    mathjax: null
    jquery: null
    smart: no
    number_sections: no
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: false
---
  
  
```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr, quietly=TRUE)
library(kableExtra, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```


# Introduction
A web coverage service (WCS) is provided for the gSSURGO and gNATGSO [map unit key grids](https://nrcs.app.box.com/v/soils). These grids represent a rasterizaion of the gSSURGO and gNATSGO map unit keys for the conterminous United States at a resolution of 30m, referenced to an Albers Equal Area Conic (NAD83) coordinate reference system (EPSG:6350). Grids are LZW compressed and internally tiled for efficient random access. Cell values are map unit keys, encoded as unsigned 32-bit integers. The grid topology and cell values are identical to the rasters contained within the gSSURGO and gNATSGO file geodatabases (FGDB). The GeoTiff format is used to ensure maximum compatibility. Files are re-created as part of the annual SSURGO refresh cycle.

A similar WCS is provided for the [ISSR-800 soil property grids](https://casoilresource.lawr.ucdavis.edu/soil-properties/).

## Grid Selection
See the [`mukey.wcs`](http://ncss-tech.github.io/soilDB/docs/reference/mukey.wcs.html) and [`ISSR800.wcs`](http://ncss-tech.github.io/soilDB/docs/reference/ISSR800.wcs.html) manual pages for details.

Basic usage.
```{r eval = FALSE}
# select gSSURGO grid
x <- mukey.wcs(aoi = aoi, db = 'gssurgo', ...)

# select gNATSGO grid
x <- mukey.wcs(aoi = aoi, db = 'gnatsgo', ...)

# select various ISSR-800 grids, details below
x <- ISSR800.wcs(aoi = aoi, var = 'paws')
```


## gSSURGO
Excerpt from the [gSSURGO documentation](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/home/?cid=nrcs142p2_053628#release).

<div style="padding: 10px; font-size:90%;">
The gSSURGO Database is derived from the official Soil Survey Geographic (SSURGO) Database. SSURGO generally has the most detailed level of soil geographic data developed by the National Cooperative Soil Survey (NCSS) in accordance with NCSS mapping standards. The tabular data represent the soil attributes and are derived from properties and characteristics stored in the National Soil Information System (NASIS). The gSSURGO data were prepared by merging the traditional vector-based SSURGO digital map data and tabular data into statewide extents, adding a statewide gridded map layer derived from the vector layer, and adding a new value-added look up table (Valu1) containing “ready to map” attributes. The gridded map layer is a file geodatabase raster in an ArcGIS file geodatabase. The raster and vector map data have a statewide extent. The raster map data have a 10-meter cell size that approximates the vector polygons in an Albers Equal Area projection. Each cell (and polygon) is linked to a map unit identifier called the map unit key. A unique map unit key is used to link the raster cells and polygons to attribute tables. Due to file size, the raster layer for the conterminous United States is only available in a 30-meter resolution.
</div>

## gNATSGO
Excerpt from the [gNATSGO documentation](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/geo/?cid=nrcseprd1464625).

<div style="padding: 10px; font-size:90%;">
The gNATSGO databases contain a raster of the soil map units and 70 related tables of soil properties and interpretations. They are designed to work with the SPSD gSSURGO ArcTools. Users can create full coverage thematic maps and grids of soil properties and interpretations for large geographic areas, such as the extent of a State or the conterminous United States. Please note that the State-wide geodatabases contain a 10 meter raster and the CONUS database contains a 30 meter raster.

The gNATSGO database is composed primarily of SSURGO data, but STATSGO2 data was used to fill in the gaps. The RSSs are newer product with relatively limited spatial extent.  These RSSs were merged into the gNATSGO after combining the SSURGO and STATSGO2 data. The extent of RSS is expected to increase in the coming years.
</div>


## Thematic Mapping
Thematic mapping or analysis of soil information requires connecting the grids to our tabular data sources, either using local files (e.g. gSSURGO / gNATSGO) or Soil Data Access (SDA). Note that map unit keys associated with raster soil surveys (included with gNATSGO) are not currently available in SDA. 


## Caveats / Limitations

Requests are limited to images sizes of 5000x5000 pixels, this is approximately 1x1 degrees at 30m.

### Remaianing TODOs
   * Ensure that data are not resampled unless a resolution other than 30m is requested.
   * Currently the data come back *close* to 30m, usually 29.998-30.111. I'm not sure if this is something that has to be solved in the creation of the BBOX or if it is a Mapserver configuration issue. Still tinkering.
   * Consider converting source mukey grids to COG-GeoTiff, this will require a newer version of GDAL.
   * Simplify / unify soil data aggregation within SDA: this is much more generic than this WCS idea, but is a perfect use case.


# A Simple Demonstration

## Setup
Need the latest version of `soilDB`, along with all packages specified below (CRAN versions fine).
```{r eval = FALSE}
remotes::install_github("ncss-tech/soilDB", dependencies = FALSE, upgrade = FALSE, build = FALSE)
```


```{r}
# latest from GitHub
library(soilDB)

# wrangling polygons and CRS transformations
library(sp)
library(rgdal)

# geometric calculations
library(rgeos)

# this is the future, will eventually replace much of 
# sp, rgdal, geos methods used here
library(sf)

# raster data visualization
library(raster)
library(rasterVis)
library(viridis)

# soil classification
library(aqp)
```


```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -114.16, xmax = -114.08, ymin = 47.65, ymax = 47.68), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# fetch gSSURGO map unit keys at native resolution (~30m)
x <- mukey.wcs(aoi = a, db = 'gssurgo')

# OK
levelplot(
  x, 
  att = 'ID',
  main = 'gSSURGO map unit keys',
  sub = 'Albers Equal Area Projection',
  margin = FALSE, 
  colorkey = FALSE, 
  col.regions = viridis
  )
```



## Fetching Polygons from SDA
```{r}
## TODO: update to sf

# convert raster extent into vector 
g <- as(extent(x), 'SpatialPolygons')
proj4string(g) <- projection(x)

# get intersecting SSURGO linework as SpatialPolygonsDataFrame from SDA
p <- SDA_spatialQuery(g, what = 'geom', geomIntersection = TRUE)

# transform to AEA CRS
p <- spTransform(p, CRS(projection(x)))

# compute area and convert square meters to acres
rgeos::gArea(p) * 0.000247105

par(mar = c(1, 0, 2, 0))
plot(p, main = 'SSURGO Polygons (SDA)')
mtext('Albers Equal Area Projection', side = 1, line = -0.5)
```


Overlay on gSSURGO grid.
```{r}
levelplot(
  x, att = 'ID', 
  main = 'gSSURGO Grid (WCS)\nSSURGO Polygons (SDA)',
  margin = FALSE, 
  colorkey = FALSE,
  col.regions = viridis,
  panel = function(...) {
    panel.levelplot(...)
    sp.lines(p, col = 'white')
  }
)
```

## Grid Resolution Specification
Native vs. alternative resolutions (preview not aggregation).

```{r}
# part of CA
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a.CA <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a.CA <- st_as_sfc(a.CA)

# fetch gSSURGO map unit keys at ~~ 800m
# nearest-neighbor resampling = this is a "preview"
x.800 <- mukey.wcs(aoi = a.CA, db = 'gssurgo', res = 800)

# OK
levelplot(
  x.800, 
  att = 'ID',
  main = 'A Preview of gSSURGO Map Unit Keys',
  sub = 'Albers Equal Area Projection (800m)\nnearest-neighbor resampling',
  margin = FALSE, 
  colorkey = FALSE, 
  col.regions = viridis,
  scales = list(draw = FALSE)
  )
```

# Tabular Data from SDA 

```{r}
# get unique mukeys from grid
ll <- levels(x)[[1]]

tab <- get_SDA_property(mukeys = ll$ID, property = 'Corrosion of Steel', method = 'DOMINANT CONDITION')

tab$corsteel <- factor(tab$corsteel, levels = c('Low', 'Moderate', 'High'))


# tab <- get_SDA_muaggatt(mukeys = ll$ID)

# tab <- get_SDA_hydric(mukeys = ll$ID)

# tab <- get_SDA_interpretation(mukeys = ll$ID, rulename = '')

# tab <- get_SDA_pmgroupname(mukeys = ll$ID, simplify = TRUE)





## TODO: SOC stock estimates

```


## RAT Management
```{r}
## TODO: NA is not encoded into the raster correctly, why?

# re-create raster attribute table with aggregate soil properties
rat <- merge(ll, tab, by.x = 'ID', by.y = 'mukey', sort = FALSE, all.x = TRUE)

# re-pack RAT
levels(x) <- rat

# check: RAT has been integrated into the RasterLayer object
x

# convert raster + RAT --> grid of values
(corsteel <- deratify(x, att = 'corsteel'))

# graphical check
levelplot(
  corsteel, 
  main = 'Corrosion of Steel',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis
  )
```

## Map Unit Aggregatation Strategies
A "soil data aggregation engine".

   * SOD SQL templates
   * R functions
   * code from ArcGIS toolboxes (python)


# Related WCS

## ISSR-800

Available datasets.
```{r, eval = FALSE}
WCS_details(wcs = 'ISSR800')
```

```{r, echo = FALSE}
kableExtra::kable_styling(knitr::kable(WCS_details(wcs = 'ISSR800'), row.names = FALSE), full_width = FALSE)
```

```{r}
# part of CA

# make a bounding box and assign a CRS (4326: GCS, WGS84)
a.CA <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a.CA <- st_as_sfc(a.CA)


# floating point grids
paws_total <- ISSR800.wcs(aoi = a.CA, var = 'paws')
paws_025cm <- ISSR800.wcs(aoi = a.CA, var = 'paws_025cm')
paws_050cm <- ISSR800.wcs(aoi = a.CA, var = 'paws_050cm')

pH_05cm <- ISSR800.wcs(aoi = a.CA, var = 'ph_05cm')
pH_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'ph_3060cm')

clay_05cm <- ISSR800.wcs(aoi = a.CA, var = 'clay_05cm')
clay_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'clay_3060cm')

silt_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'silt_3060cm')
sand_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'sand_3060cm')

## NA encoding issues
# 0 is a real value
sar <- ISSR800.wcs(aoi = a.CA, var = 'sar')

# 16bit integer grids
wei <- ISSR800.wcs(aoi = a.CA, var = 'wei')

# 8bit unsigned (BYTE) grids with RAT
drainage_class <- ISSR800.wcs(aoi = a.CA, var = 'drainage_class')
weg <- ISSR800.wcs(aoi = a.CA, var = 'weg')
str <- ISSR800.wcs(aoi = a.CA, var = 'str')
```

```{r}
# compositional data may lose some fidelity due to marginal aggregation
z <- sand_3060cm + silt_3060cm + clay_3060cm
levelplot(z - 100, margin = FALSE)
```

Soil texture class 25-50cm.
```{r}
texture_2550cm <- ISSR800.wcs(aoi = a.CA, var = 'texture_2550cm')

# use colors from RAT
cols <- levels(texture_2550cm)[[1]]$hex
levelplot(texture_2550cm, att = 'class', margin = FALSE, col.regions = cols)
```


```{r}
levelplot(sar, margin = FALSE)

levelplot(wei, margin = FALSE)

levelplot(drainage_class, margin = FALSE)
levelplot(weg, margin = FALSE)
levelplot(str, margin = FALSE)
```

```{r fig.width = 10, fig.height=6}
levelplot(stack(pH_05cm, pH_3060cm), margin = FALSE)

levelplot(stack(clay_05cm, clay_3060cm), margin = FALSE)

levelplot(stack(sand_3060cm, silt_3060cm, clay_3060cm), margin = FALSE)
```



### Soil / Land Classification
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -114.20, xmax = -114.10, ymin = 47.65, ymax = 47.70), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# get
greatgroup <- ISSR800.wcs(aoi = a, var = 'greatgroup')
lcc_irrigated <- ISSR800.wcs(aoi = a, var = 'lcc_irrigated')

# plot
levelplot(greatgroup, margin = FALSE)
levelplot(lcc_irrigated, margin = FALSE)
```


### Soil Color
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# most frequent soil series per grid cell
series_name <- ISSR800.wcs(aoi = a, var = 'series_name')

# extract unique soil series names
rat <- levels(series_name)[[1]]

# query morphology from OSDs
osds <- fetchOSD(soils = rat$series_name)

# extract soil color at 25cm
s <- slice(osds, fm = 25 ~ soil_color, just.the.data = TRUE, strict = FALSE)

# subset columns / re-name for simpler join
s.colors <- s[, c(idname(osds), 'soil_color')]
names(s.colors)[1] <- 'series_name'

# join with original RAT / re-order columns for packing into raster object
rat.new <- merge(rat, s.colors, by = 'series_name', sort = FALSE, all.x = TRUE)
rat.new <- rat.new[, c('ID', 'series_name', 'soil_color')]

# replace old RAT with new RAT containing soil colors
levels(series_name) <- rat.new

# simple figure
levelplot(series_name, margin = FALSE, col.regions = rat.new$soil_color, colorkey = FALSE, main = 'Moist Soil Colors at 25cm', sub = 'Source: most frequent series / 800m cell and OSDs', scales = list(draw = FALSE))
```



### Classification
```{r}
# part of CA

# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# EC 0-25cm
ec <- ISSR800.wcs(aoi = a, var = 'ec_025cm')

# pH 0-25cm
pH <- ISSR800.wcs(aoi = a, var = 'ph_025cm')

# no ESP grid, use a constant value of 1%
esp <- ec
values(esp) <- 1

# copy EC grid, replace values with classification in next step
ss <- ec

# resulting raster contains factor levels (integers) and labels
values(ss) <- allocate(EC = values(ec), pH = values(pH), ESP = values(esp), to = 'FAO Salt Severity', droplevels = TRUE)

# note factor details stored in raster attribute table (RAT)
print(ss)

# plot
levelplot(ss, margin = FALSE, main = 'FAO Salt Severity')
```


For larger objects, consider the alternative. Hmm: `Error in setValues(out, vals) : values must be numeric, logical or factor`.
```{r eval = FALSE}
ss <- overlay(
  pH, ec, esp,
  fun = function(.pH, .ec, .esp) {
    
    # this doesn't seem to help
    # .ec <- ifelse(is.na(.ec), 0, .ec)
    # .pH <- ifelse(is.na(.pH), 7, .pH)
    
    res <- allocate(EC = .ec, pH = .pH, ESP = .esp, to = 'FAO Salt Severity', droplevels = FALSE)
    return(res)
  }
)

levelplot(ss, margin = FALSE, main = 'FAO Salt Severity')
```




## PRISM Stack

## Others


----------------------------
This document is based on `soilDB` version `r utils::packageDescription("soilDB", field="Version")`.


