---
title: "gNATSGO / gSSURGO Web Coverage Service"
author: "D.E. Beaudette"
date: "`r Sys.Date()`"
output:
  html_document:
    mathjax: null
    jquery: null
    smart: no
    number_sections: no
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: false
---
  
  
```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr, quietly=TRUE)
library(kableExtra, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```


# Introduction
A web coverage service (WCS) is provided for the gSSURGO and gNATGSO [map unit key grids](https://nrcs.app.box.com/v/soils). These grids represent a rasterizaion of the gSSURGO and gNATSGO map unit keys for the conterminous United States at a resolution of 30m, referenced to an Albers Equal Area Conic (NAD83) coordinate reference system (EPSG:5070). Grids are LZW compressed and internally tiled for efficient random access. Cell values are map unit keys, encoded as unsigned 32-bit integers. The grid topology and cell values are identical to the rasters contained within the gSSURGO and gNATSGO file geodatabases (FGDB). The GeoTiff format is used to ensure maximum compatibility. Files are re-created as part of the annual SSURGO refresh cycle.

A similar WCS is provided for the [ISSR-800 soil property grids](https://casoilresource.lawr.ucdavis.edu/soil-properties/).

## Grid Selection
See the [`mukey.wcs`](http://ncss-tech.github.io/soilDB/docs/reference/mukey.wcs.html) and [`ISSR800.wcs`](http://ncss-tech.github.io/soilDB/docs/reference/ISSR800.wcs.html) manual pages for details.

Basic usage.
```{r eval = FALSE}
# select gSSURGO grid
x <- mukey.wcs(aoi = aoi, db = 'gssurgo', ...)

# select gNATSGO grid
x <- mukey.wcs(aoi = aoi, db = 'gnatsgo', ...)

# select various ISSR-800 grids, details below
x <- ISSR800.wcs(aoi = aoi, var = 'paws')
```


## gSSURGO
Excerpt from the [gSSURGO documentation](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/home/?cid=nrcs142p2_053628#release).

<div style="padding: 10px; font-size:90%;">
The gSSURGO Database is derived from the official Soil Survey Geographic (SSURGO) Database. SSURGO generally has the most detailed level of soil geographic data developed by the National Cooperative Soil Survey (NCSS) in accordance with NCSS mapping standards. The tabular data represent the soil attributes and are derived from properties and characteristics stored in the National Soil Information System (NASIS). The gSSURGO data were prepared by merging the traditional vector-based SSURGO digital map data and tabular data into statewide extents, adding a statewide gridded map layer derived from the vector layer, and adding a new value-added look up table (Valu1) containing “ready to map” attributes. The gridded map layer is a file geodatabase raster in an ArcGIS file geodatabase. The raster and vector map data have a statewide extent. The raster map data have a 10-meter cell size that approximates the vector polygons in an Albers Equal Area projection. Each cell (and polygon) is linked to a map unit identifier called the map unit key. A unique map unit key is used to link the raster cells and polygons to attribute tables. Due to file size, the raster layer for the conterminous United States is only available in a 30-meter resolution.
</div>

## gNATSGO
Excerpt from the [gNATSGO documentation](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/geo/?cid=nrcseprd1464625).

<div style="padding: 10px; font-size:90%;">
The gNATSGO databases contain a raster of the soil map units and 70 related tables of soil properties and interpretations. They are designed to work with the SPSD gSSURGO ArcTools. Users can create full coverage thematic maps and grids of soil properties and interpretations for large geographic areas, such as the extent of a State or the conterminous United States. Please note that the State-wide geodatabases contain a 10 meter raster and the CONUS database contains a 30 meter raster.

The gNATSGO database is composed primarily of SSURGO data, but STATSGO2 data was used to fill in the gaps. The RSSs are newer product with relatively limited spatial extent.  These RSSs were merged into the gNATSGO after combining the SSURGO and STATSGO2 data. The extent of RSS is expected to increase in the coming years.
</div>


## Thematic Mapping
Thematic mapping or analysis of soil information requires connecting the grids to our tabular data sources, either using local files (e.g. gSSURGO / gNATSGO) or Soil Data Access (SDA). Note that map unit keys associated with raster soil surveys (included with gNATSGO) are not currently available in SDA. 


## Caveats / Limitations

Requests are limited to images sizes of 5000x5000 pixels, this is approximately 1x1 degrees at 30m.

### Remaianing TODOs
   * Ensure that data are not resampled unless a resolution other than 30m is requested.
   * Currently the data come back *close* to 30m, usually 29.998-30.111. I'm not sure if this is something that has to be solved in the creation of the BBOX or if it is a Mapserver configuration issue. Still tinkering.
   * Consider converting source mukey grids to COG-GeoTiff, this will require a newer version of GDAL.


# Setup
Need the latest version of `soilDB`, along with all packages specified below (CRAN versions fine).
```{r eval = FALSE}
install.packages('soilDB')
remotes::install_github("ncss-tech/soilDB", dependencies = FALSE, upgrade = FALSE, build = FALSE)
```

Load required package.
```{r}
# latest from GitHub
library(soilDB)

# wrangling polygons and CRS transformations
library(sp)
library(rgdal)

# geometric calculations
library(rgeos)

# this is the future, will eventually replace much of 
# sp, rgdal, geos methods used here
library(sf)

# raster data visualization
library(raster)
library(rasterVis)
library(viridis)

# soil classification
library(aqp)
```


# Map Unit Key Grids

Use the `mukey.wcs()` function to access chunks of the CONUS map unit key grids, based on some representation of an area of interest (AOI). The AOI can be defined manually, as below, or automatically extracted from `Spatial*`, `RasterLayer`, `sf`, `sfc` or `bbox` objects. The resulting grid of integers isn't all that useful by itself; join data from Soil Data Access (SDA) or local files (by map unit key) to create thematic maps. Note: the gSSURGO and gNATSGO grids are updated annually, and typically in-sync with the live version of the data hosted by SDA (updated Oct 1st) by early November. Map unit keys can change over time, especially in soil survey areas that were updated during the last fiscal year.
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -114.16, xmax = -114.08, ymin = 47.65, ymax = 47.68), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# fetch gSSURGO map unit keys at native resolution (~30m)
x <- mukey.wcs(aoi = a, db = 'gssurgo')

# looks good
levelplot(
  x, 
  att = 'ID',
  main = 'gSSURGO map unit keys',
  sub = 'Albers Equal Area Projection',
  margin = FALSE, 
  colorkey = FALSE, 
  col.regions = viridis
  )
```



## SSURGO Polygons from SDA
It is possible to retrieve small areas of vector geometry (SSURGO polygons) from SDA with the `SDA_spatialQuery()` function. These data are stored and delivered in a geographic coordinate system (WGS84). Overlaying the SSURGO polygons and map unit key grids will require a simple transformation.
```{r}
# note: SDA_spatialQuery() expects an sp object
# convert raster extent into vector 
g <- as(extent(x), 'SpatialPolygons')
proj4string(g) <- projection(x)

# get intersecting SSURGO linework as SpatialPolygonsDataFrame from SDA
p <- SDA_spatialQuery(g, what = 'mupolygon', geomIntersection = TRUE)

# transform to AEA CRS
p <- spTransform(p, CRS(projection(x)))

# compute area and convert square meters to acres
# rgeos::gArea(p) * 0.000247105

par(mar = c(1, 0, 2, 0))
plot(p, main = 'SSURGO Polygons (SDA)')
mtext('Albers Equal Area Projection', side = 1, line = -0.5)
```


That looks about right.
```{r}
levelplot(
  x, att = 'ID', 
  main = 'gSSURGO Grid (WCS)\nSSURGO Polygons (SDA)',
  margin = FALSE, 
  colorkey = FALSE,
  col.regions = viridis,
  panel = function(...) {
    panel.levelplot(...)
    sp.lines(p, col = 'white')
  }
)
```

## Grid Resolution Specification
Requesting map unit key grids at a resolution other than 30m is possible, but only suitable for a quick "preview" of the data. For example, it is possible to get a much larger chunk of data by requesting grids at 800m. However, pixels are selected by nearest-neighbor and not generalized to the coarser scale. In short: don't use the resulting data for anything other than a simple preview.

```{r}
# part of CA
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a.CA <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a.CA <- st_as_sfc(a.CA)

# fetch gSSURGO map unit keys at ~~ 800m
# nearest-neighbor resampling = this is a "preview"
x.800 <- mukey.wcs(aoi = a.CA, db = 'gssurgo', res = 800)

# OK
levelplot(
  x.800, 
  att = 'ID',
  main = 'A Preview of gSSURGO Map Unit Keys',
  sub = 'Albers Equal Area Projection (800m)\nnearest-neighbor resampling',
  margin = FALSE, 
  colorkey = FALSE, 
  col.regions = viridis,
  scales = list(draw = FALSE)
  )
```



# Examples


## Several horizon-level soil properties

```{r}
# https://casoilresource.lawr.ucdavis.edu/gmap/?loc=36.57666,-96.70175,z14
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -96.7696, xmax = -96.6477, ymin = 36.5477, ymax = 36.6139), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)


# keyboard shortcuts at:
# https://casoilresource.lawr.ucdavis.edu/gmap/
# 'b' copy bounding-box
# 'p' copy center coordinate

# read-in AOI from shape file or similar
# a <- st_read('file.shp')


# fetch gSSURGO map unit keys at native resolution (~30m)
mu <- mukey.wcs(aoi = a, db = 'gssurgo')

# check: OK
levelplot(
  mu, 
  att = 'ID', 
  margin = FALSE, 
  colorkey = FALSE, 
  scales = list(draw = FALSE),
  col.regions = viridis
)

# get unique map unit keys
ll <- levels(mu)[[1]]

# get / aggregate specific horizon-level properties from SDA
# be sure to see the manual page for this function
p <-  get_SDA_property(property = c("dbthirdbar_r", "awc_r", "ph1to1h2o_r"),
                       method = "Dominant Component (Numeric)", 
                       mukeys = ll$ID,
                       top_depth = 0,
                       bottom_depth = 25)


# check: OK
head(p)

#  convert areasymbol into a factor easy plotting later
p$areasymbol <- factor(p$areasymbol)


# combine unique mukey + data from SDA into a new raster attribute table (RAT)
rat <- merge(ll, p, by.x = 'ID', by.y = 'mukey', sort = FALSE, all.x = TRUE)

# re-pack RAT
levels(mu) <- rat

# convert raster + RAT --> stack of values
Db <- deratify(mu, att = "dbthirdbar_r")
AWC <- deratify(mu, att = "awc_r")
pH <- deratify(mu, att = "ph1to1h2o_r")
ssa <- deratify(mu, att = "areasymbol")

# graphical check

levelplot(
  ssa,
  main = 'Soil Survey Area',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis,
  maxpixels = 1e5
)


# note implicit simplification via maxpixels
levelplot(
  Db, 
  main = '1/3 Bar Bulk Density (g/cm^3)\n0-25cm\nDominant Component',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis,
  maxpixels = 1e5
)

levelplot(
  AWC, 
  main = 'AWC (cm/cm) 0-25cm\nDominant Component',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis,
  maxpixels = 1e5
)

levelplot(
  pH, 
  main = 'pH 1:1 H2O 0-25cm\nDominant Component',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis,
  maxpixels = 1e5
)

```


## Sand, Silt, and Clay at a Soil Survey Area Boundary
A not so great SSA join (1979 vs 2004).


```{r}
# extract a BBOX like this from SoilWeb by pressing "b"
bb <- '-91.6853 36.4617,-91.6853 36.5281,-91.5475 36.5281,-91.5475 36.4617,-91.6853 36.4617'
wkt <- sprintf('POLYGON((%s))', bb)

x <- st_as_sfc(wkt)
st_crs(x) <- 4326


# get gSSURGO grid here
mu <- mukey.wcs(aoi = x, db = 'gssurgo')

# unique map unit keys
ll <- levels(mu)[[1]]

# note SSA boundary
levelplot(mu, att = 'ID', margin = FALSE, colorkey = FALSE, col.regions = viridis)

# get thematic data from SDA
# dominant component
# depth-weighted average
# sand, silt, clay (RV)
p <-  get_SDA_property(property = c("sandtotal_r","silttotal_r","claytotal_r"),
                       method = "Dominant Component (Numeric)", 
                       mukeys = ll$ID,
                       top_depth = 25,
                       bottom_depth = 50)

head(p)

# re-create raster attribute table with aggregate soil properties
rat <- merge(ll, p, by.x = 'ID', by.y = 'mukey', sort = FALSE, all.x = TRUE)

# re-pack RAT
levels(mu) <- rat

# convert raster + RAT --> stack of values
ssc <- deratify(mu, c("sandtotal_r","silttotal_r","claytotal_r"))

# graphical check
# note implicit simplification via maxpixels
levelplot(
  ssc, 
  main = 'Sand, Silt, Clay (RV) 25-50cm\nDominant Component',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis,
  maxpixels = 1e4
)


```

## Component level properties
Steel corrosion potential.
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -114.16, xmax = -114.08, ymin = 47.65, ymax = 47.68), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# fetch gSSURGO map unit keys at native resolution (~30m)
x <- mukey.wcs(aoi = a, db = 'gssurgo')

# get unique mukeys from grid
ll <- levels(x)[[1]]

tab <- get_SDA_property(mukeys = ll$ID, property = 'Corrosion of Steel', method = 'DOMINANT CONDITION')

tab$corsteel <- factor(tab$corsteel, levels = c('Low', 'Moderate', 'High'))


# re-create raster attribute table with aggregate soil properties
rat <- merge(ll, tab, by.x = 'ID', by.y = 'mukey', sort = FALSE, all.x = TRUE)

# re-pack RAT
levels(x) <- rat

# check: RAT has been integrated into the RasterLayer object
x

# convert raster + RAT --> grid of values
(corsteel <- deratify(x, att = 'corsteel'))

# graphical check
levelplot(
  corsteel, 
  main = 'Corrosion of Steel',
  margin = FALSE, 
  scales = list(draw = FALSE), 
  col.regions = viridis
  )
```


## TODO SOC Stock Estimates

## Additional interfaces to SDA with aggregation

```{r eval=FALSE}

# tab <- get_SDA_muaggatt(mukeys = ll$ID)

# tab <- get_SDA_hydric(mukeys = ll$ID)

# tab <- get_SDA_interpretation(mukeys = ll$ID, rulename = '')

# tab <- get_SDA_pmgroupname(mukeys = ll$ID, simplify = TRUE)

```




# Other Relevant WCS

## ISSR-800

Available datasets.
```{r, eval = FALSE}
WCS_details(wcs = 'ISSR800')
```
ee
```{r, echo = FALSE}
kableExtra::kable_styling(knitr::kable(WCS_details(wcs = 'ISSR800'), row.names = FALSE), full_width = FALSE)
```

```{r}
# part of CA

# make a bounding box and assign a CRS (4326: GCS, WGS84)
a.CA <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a.CA <- st_as_sfc(a.CA)


# floating point grids
paws_total <- ISSR800.wcs(aoi = a.CA, var = 'paws')
paws_025cm <- ISSR800.wcs(aoi = a.CA, var = 'paws_025cm')
paws_050cm <- ISSR800.wcs(aoi = a.CA, var = 'paws_050cm')

pH_05cm <- ISSR800.wcs(aoi = a.CA, var = 'ph_05cm')
pH_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'ph_3060cm')

clay_05cm <- ISSR800.wcs(aoi = a.CA, var = 'clay_05cm')
clay_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'clay_3060cm')

silt_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'silt_3060cm')
sand_3060cm <- ISSR800.wcs(aoi = a.CA, var = 'sand_3060cm')

## NA encoding issues
# 0 is a real value
sar <- ISSR800.wcs(aoi = a.CA, var = 'sar')

# 16bit integer grids
wei <- ISSR800.wcs(aoi = a.CA, var = 'wei')

# 8bit unsigned (BYTE) grids with RAT
drainage_class <- ISSR800.wcs(aoi = a.CA, var = 'drainage_class')
weg <- ISSR800.wcs(aoi = a.CA, var = 'weg')
str <- ISSR800.wcs(aoi = a.CA, var = 'str')
```

```{r}
# compositional data may lose some fidelity due to marginal aggregation
z <- sand_3060cm + silt_3060cm + clay_3060cm
levelplot(z - 100, margin = FALSE)
```

Soil texture class 25-50cm.
```{r}
texture_2550cm <- ISSR800.wcs(aoi = a.CA, var = 'texture_2550cm')

# use colors from RAT
cols <- levels(texture_2550cm)[[1]]$hex
levelplot(texture_2550cm, att = 'class', margin = FALSE, col.regions = cols)
```


```{r}
levelplot(sar, margin = FALSE)

levelplot(wei, margin = FALSE)

levelplot(drainage_class, margin = FALSE)
levelplot(weg, margin = FALSE)
levelplot(str, margin = FALSE)
```

```{r fig.width = 10, fig.height=6}
levelplot(stack(pH_05cm, pH_3060cm), margin = FALSE)

levelplot(stack(clay_05cm, clay_3060cm), margin = FALSE)

levelplot(stack(sand_3060cm, silt_3060cm, clay_3060cm), margin = FALSE)
```



### Soil / Land Classification
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -114.20, xmax = -114.10, ymin = 47.65, ymax = 47.70), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# get
greatgroup <- ISSR800.wcs(aoi = a, var = 'greatgroup')
lcc_irrigated <- ISSR800.wcs(aoi = a, var = 'lcc_irrigated')

# plot
levelplot(greatgroup, margin = FALSE)
levelplot(lcc_irrigated, margin = FALSE)
```


### Soil Color
```{r}
# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# most frequent soil series per grid cell
series_name <- ISSR800.wcs(aoi = a, var = 'series_name')

# extract unique soil series names
rat <- levels(series_name)[[1]]

# query morphology from OSDs
osds <- fetchOSD(soils = rat$series_name)

# extract soil color at 25cm
s <- slice(osds, fm = 25 ~ soil_color, just.the.data = TRUE, strict = FALSE)

# subset columns / re-name for simpler join
s.colors <- s[, c(idname(osds), 'soil_color')]
names(s.colors)[1] <- 'series_name'

# join with original RAT / re-order columns for packing into raster object
rat.new <- merge(rat, s.colors, by = 'series_name', sort = FALSE, all.x = TRUE)
rat.new <- rat.new[, c('ID', 'series_name', 'soil_color')]

# replace old RAT with new RAT containing soil colors
levels(series_name) <- rat.new

# simple figure
levelplot(series_name, margin = FALSE, col.regions = rat.new$soil_color, colorkey = FALSE, main = 'Moist Soil Colors at 25cm', sub = 'Source: most frequent series / 800m cell and OSDs', scales = list(draw = FALSE))
```



### Classification
```{r}
# part of CA

# make a bounding box and assign a CRS (4326: GCS, WGS84)
a <- st_bbox(
  c(xmin = -121, xmax = -120, ymin = 37, ymax = 38), 
  crs = st_crs(4326)
)

# convert bbox to sf geometry
a <- st_as_sfc(a)

# EC 0-25cm
ec <- ISSR800.wcs(aoi = a, var = 'ec_025cm')

# pH 0-25cm
pH <- ISSR800.wcs(aoi = a, var = 'ph_025cm')

# no ESP grid, use a constant value of 1%
esp <- ec
values(esp) <- 1

# copy EC grid, replace values with classification in next step
ss <- ec

# resulting raster contains factor levels (integers) and labels
values(ss) <- allocate(EC = values(ec), pH = values(pH), ESP = values(esp), to = 'FAO Salt Severity', droplevels = TRUE)

# note factor details stored in raster attribute table (RAT)
print(ss)

# plot
levelplot(ss, margin = FALSE, main = 'FAO Salt Severity')
```


For larger objects, consider the alternative. Hmm: `Error in setValues(out, vals) : values must be numeric, logical or factor`.
```{r eval = FALSE}
ss <- overlay(
  pH, ec, esp,
  fun = function(.pH, .ec, .esp) {
    
    # this doesn't seem to help
    # .ec <- ifelse(is.na(.ec), 0, .ec)
    # .pH <- ifelse(is.na(.pH), 7, .pH)
    
    res <- allocate(EC = .ec, pH = .pH, ESP = .esp, to = 'FAO Salt Severity', droplevels = FALSE)
    return(res)
  }
)

levelplot(ss, margin = FALSE, main = 'FAO Salt Severity')
```




## PRISM Stack

## Others


----------------------------
This document is based on `soilDB` version `r utils::packageDescription("soilDB", field="Version")`.


