---
title: "Competing Soil Series"
author: "D.E. Beaudette"
date: "`r Sys.Date()`"
output:
  html_document:
  mathjax: null
jquery: null
smart: no
---


```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr, quietly=TRUE)
library(kableExtra, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```

This is rough outline for evalutating potential differences between soil series within the same family, e.g. competing series. For this example, start the process by loading data within the same family as the [Drummer](https://casoilresource.lawr.ucdavis.edu/sde/?series=Drummer) series; *fine-silty, mixed, superactive, mesic typic endoaquolls*.

Why do this?

   * reviewing the criteria for competing soil series is problematic when OSDs haven't been updated
   * this process should be less subjective and as quantitative as possible
   * the "Competing Series" section of the OSD can be made more informative via graphics
   * there is usually more to the story than single "difference"
   


## Setup

Load relevant packages and define some helper functions.
```{r fig.width=9, fig.height=6}
# you will need the latest version of soilDB
library(soilDB)
library(sharpshootR)
library(latticeExtra)
library(RColorBrewer)
library(reshape2)
library(cluster)
library(ape)
library(scales)
library(maps)


# convenience function for getting KSSL data by soil series name
getPedons <- function(x) {
  suppressMessages(fetchKSSL(series=x))
}
```

## Get Data

Get *extended* summaries for the Drummer soil series. As of `soilDB` 2.3 this includes a list of "competing" soil series.
```{r}
soil <- 'DRUMMER'
s <- fetchOSD(soil, extended = TRUE)
```

Get extended summaries for Drummer and competing series.
```{r}
# get competing series OSD data
spc <- fetchOSD(c(soil, s$competing$competing))

# this will only work for established series, e.g. those that have been "mapped" somewhere
idx <- which(spc$series_status == 'established')
spc <- spc[idx, ]

# save family taxa and set of series names for later
fm.name <- unique(na.omit(spc$family))
s.names <- unique(site(spc)$id)
```


### First Look

Plot sketches of the soils in this family, data are from OSDs via SoilWeb.
```{r fig.width=12, fig.height=6}
# plot
par(mar=c(0.25,0,1,1))
plot(spc)
mtext(fm.name, side = 3, at = 0.5, adj = 0, line = -1, font=4)
mtext('source: Official Series Descriptions', side = 1, at = 0.5, adj = 0, line = -1, font=3, cex=1)
```


## Climate Summaries

Compare [annual climate summaries](https://ncss-tech.github.io/AQP/soilDB/series-climate-summary-eval.html) using divisive hierarchical clustering of median values.
```{r}
# get OSD + extended summaries for all competing series
s.competing.data <- fetchOSD(s.names, extended = TRUE)

# make a copy of the annual climate data
s.ca <- s.competing.data$climate.annual

# widen for clustering of medians
s.ca.wide <- dcast(s.ca, series ~ climate_var, value.var = 'q50')
# save row names for labeling later
row.names(s.ca.wide) <- s.ca.wide$series

# re-order based on divisive hierarchical clustering of medians
# keep cluster pkg class for dendrogram + profile sketches
s.ca.d <- diana(daisy(s.ca.wide[, -1], stand = TRUE))
# convert to hclust class for ordering of series in climate summaries
s.ca.h <- as.hclust(s.ca.d)
s.ca$series <- factor(s.ca$series, levels=s.ca.h$labels[s.ca.h$order])
```

Vizualize pair-wise distances using a dendrogram and profile sketches. What do the two main groupings tell us about this family?
```{r fig.width=12, fig.height=6}
par(mar=c(0,0,1,1))
plotProfileDendrogram(s.competing.data$SPC, clust = s.ca.d, scaling.factor = 0.075, width = 0.2, y.offset = 0.5)
mtext(fm.name, side = 1, at = 0.5, adj = 0, line = -1.5, font=4)
```

Evaluate individual climate variables using select percentiles. Soil series labels are sorted according to divisive hierarchical clustering. The two main groupings are clearly visible in those climate varibles linked to mean annual air temperature.
```{r fig.width=12, fig.height=8}
segplot(series ~ q05 + q95 | factor(climate_var), centers=q50, data=s.ca, main=fm.name, draw.bands=FALSE, segments.fun=panel.arrows, ends='both', angle=90, length=1, unit='mm', scales=list(y=list(alternating=3), x=list(relation='free')), as.table=TRUE, col='RoyalBlue', strip=strip.custom(bg=grey(0.85), par.strip.text=list(cex=0.7)), xlab='5th-25th-50th-75th-95th Percentiles', panel=function(x, y, z, q25=s.ca$q25, q75=s.ca$q75, subscripts, ...) {
  # basic plot
  panel.grid(h=FALSE, v=-1, col='grey', lty=3)
  panel.abline(h=1:length(unique(s.ca$series)), col='grey', lty=3)
  panel.segplot(x, y, z, subscripts=subscripts, ...)
  
  # add interquartile range
  q25 <- q25[subscripts]
  q75 <- q75[subscripts]
  zz <- z[subscripts]
  panel.rect(xleft=q25, xright=q75, ybottom=as.numeric(zz) - 0.025, ytop=as.numeric(zz) + 0.025, border='RoyalBlue', col='RoyalBlue')
})
```

## Geomorphic Summaries

Compare hillslope position.
```{r fig.width=12, fig.height=5, echo=FALSE}
res <- vizHillslopePosition(s.competing.data$hillpos)
print(res$fig)
```

Compare geomorphic component.
```{r fig.width=12, fig.height=5, echo=FALSE}
res <- vizGeomorphicComponent(s.competing.data$geomcomp)
print(res$fig)
```


## Color Signatures

Develop a [color signature](https://ncss-tech.github.io/AQP/aqp/soil-color-signatures.html) for this family.
```{r}
# extract a local copy of the SPC
spc <- s.competing.data$SPC

# convert moist Munsell colors -> sRGB
s.rgb <- munsell2rgb(spc$hue, spc$value, spc$chroma, return_triplets = TRUE)

# copy over to hz-level attributes
spc$r <- s.rgb$r
spc$g <- s.rgb$g
spc$b <- s.rgb$b

# get color signature for each series
pig <- soilColorSignature(spc, RescaleLightnessBy = 5, method = 'pam', pam.k = 3)

# move row names over for distance matrix
row.names(pig) <- pig[, 1]
d <- daisy(pig[, -1])
dd <- diana(d)
```

Hang profile sketches from divisive hierarchical clustering of soil color signatures.
```{r fig.width=12, fig.height=5}
par(mar=c(1,0,1,1))
plotProfileDendrogram(spc, dd, dend.y.scale = max(d) * 2, scaling.factor = 0.3, y.offset = 2, width=0.15, cex.names=0.45)
mtext(fm.name, side = 1, at = 0.5, adj = 0, line = -1, font=4)
```


## MLRA and Parent Material Summaries

This needs more work.

### Parent Material
Quickly tabulate parent material kind.
```{r}
kable(sort(table(s.competing.data$pmkind$pmkind), decreasing = TRUE), format = 'html')
```

Quickly tabulate parent material origin.
```{r}
kable(sort(table(s.competing.data$pmorigin$pmorigin), decreasing = TRUE), format = 'html')
```

### MLRA
Summarize acreage by MLRA.
```{r eval=FALSE}
plyr::ddply(s.competing.data$mlra, 'mlra', .fun=plyr::summarize, total_ac=sum(area_ac))
```


## Investigate Spatial Patterns
Finish this

Make a rough sketch of the [joint extent of the series](http://ncss-tech.github.io/AQP/soilDB/series-extent.html) in this family.
```{r fig.width=8, fig.height=6, results='hide'}
# define some nice colors
cols <- brewer.pal('Set1', n=3)

## TODO: split into groups identified above
# cutree(s.ca.h, 2)

# get list of extents
l <- lapply(unique(spc$id), seriesExtent)

# map of CONUS
par(mar=c(1 ,1,1,1))
map('state')

# rough estimation of joint density via transparency  / overlay
lapply(l, function(i) {
  plot(i, border=NA, col=alpha(cols[2], 0.33), add=TRUE)
  })

# finish map
box()
title(main=fm.name, line=1.25)
```

## KSSL Data

Get KSSL data from these series via `fetchKSSL`.
```{r}
# get associated KSSL data for these series
kssl.data <- lapply(s.names, getPedons)

# some may not have any data, filter those out
not.null <- which(! sapply(kssl.data, is.null))
# combine into single SPC
kssl.data <- do.call('rbind', kssl.data[not.null])

# normalize soil series names
for(i in s.names)
  kssl.data$taxonname[grep(i, kssl.data$taxonname, ignore.case = TRUE)] <- toupper(i)
```

Tabulate number of KSSL pedons / series name.
```{r}
kable_styling(kable(table(kssl.data$taxonname), format = 'html'), full_width = FALSE)
```


Aggregate over all data within this family via `slab`, and display median bounded by inter-quartile range.
```{r fig.width=10, fig.height=6}
# aggregate over entire collection, marginal quantiles of select properties
g.slab <- slab(kssl.data, ~ clay + sand + estimated_ph_h2o + cec7 + bs82)
levels(g.slab$variable) <- c('Clay (%)', 'Sand (%)', 'pH 1:1 H2O', 'CEC at pH 7 (cmol[+]/kg)' ,'Base Saturation at pH 8.2 (%)')

# define plotting style
tps <- list(superpose.line=list(col=c('RoyalBlue', 'DarkRed', 'DarkGreen'), lwd=2))

xyplot(top ~ p.q50 | variable, data=g.slab, ylab='Depth', main=fm.name, sub='source: KSSL',
       xlab='median bounded by 25th and 75th percentiles',
       lower=g.slab$p.q25, upper=g.slab$p.q75, ylim=c(205,-5),
       panel=panel.depth_function, alpha=0.25, sync.colors=TRUE,
       prepanel=prepanel.depth_function,
       cf=g.slab$contributing_fraction,
       par.strip.text=list(cex=0.8),
       strip=strip.custom(bg=grey(0.85)),
       layout=c(5,1), scales=list(x=list(alternating=1, relation='free'), y=list(alternating=3)),
       par.settings=tps,
       auto.key=list(columns=3, lines=TRUE, points=FALSE)
)
```


Aggregate just Drummer data and compare with entire family. Note that Drummer records make up about 20% of the data within this family.
```{r fig.width=10, fig.height=6}
# compare a single profile to the group-level aggregate values
a <- slab(kssl.data[which(kssl.data$taxonname == soil), ], ~ clay + sand + estimated_ph_h2o + cec7 + bs82)
levels(a$variable) <- c('Clay (%)', 'Sand (%)', 'pH 1:1 H2O', 'CEC at pH 7 (cmol[+]/kg)' ,'Base Saturation at pH 8.2 (%)')


# manually update the group column
a$group <- soil
# a$p.q25 <- NA
# a$p.q75 <- NA
g.slab$group <- 'ALL'

# combine into a single data.frame:
g <- rbind(g.slab, a)
g$group <- factor(g$group)

xyplot(top ~ p.q50 | variable, groups=group, data=g, ylab='Depth', main=fm.name,
       xlab='median bounded by 25th and 75th percentiles', sub='source: KSSL' ,
       lower=g$p.q25, upper=g$p.q75, ylim=c(205,-5),
       panel=panel.depth_function, alpha=0.25, sync.colors=TRUE,
       prepanel=prepanel.depth_function,
       # cf=g$contributing_fraction,
       par.strip.text=list(cex=0.8),
       strip=strip.custom(bg=grey(0.85)),
       layout=c(5,1), scales=list(x=list(alternating=1, relation='free'), y=list(alternating=3)),
       par.settings=tps,
       auto.key=list(columns=2, lines=TRUE, points=FALSE)
)
```


----------------------------
This document is based on `aqp` version `r utils::packageDescription("aqp", field="Version")` and `soilDB` version `r utils::packageDescription("soilDB", field="Version")`.

